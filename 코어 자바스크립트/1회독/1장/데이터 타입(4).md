# 데이터 타입(4) :star:
- 자바스크립트가 데이터를 처리하는 과정을 살펴봄으로써 **기본형 타입** 과 **참조형 타입** 이 서로 다르게 동작하는 이유를 이해하고 이를 적절히 활용할 수 있게 되는 것을 목표로 한다.

## :question: 기본형 데이터와 참조형 데이터
### :meat_on_bone: 불변값
- 변수와 상수를 구분하는 성질은 '변경 가능성' 이다. 바꿀 수 있으면 **변수** 
바꿀 수 없으면 **상수** 이다.

- 불변값과 상수를 같은 개념으로 오해하기 쉽기에 명확히 구분할 수 있어야 한다.   
변수와 상수를 구분 짓는 변경 가능성의 대상은 **변수 영역** 메모리이다.
한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건이다.반면 불변성 여부를 구분할 때의 변경 가능성의 대상은 **데이터 영역** 메모리이다.

- **기본형 데이터** 에는 **숫자, 문자열, boolean, null, undefined, Symbol** 이 있고, 이 것은 모두 **불변값** 이다.

<변수>
```js
let a = 0;
console.log(a);
// Expected output : 0

a = 1;
console.log(a);
// Expected output : 1
```
<상수>
```js
const a = 0;
console.log(a);
// Expected output : 0

a  = 1;
console.log(a);
// Expected output : const 'TypeError: Assignment to constant variable.'
```

:bulb: const 는 constant 의 앞을 딴 것으로 **상수** 를 선언하는 자료형이다.

<예제>

```js
let a = 'hello';
console.log(a);
// Expected output : 'hello'

a += ' world';
console.log(a);
// Expected output : 'hello world'

let b = 7;
let c = 7;
console.log(b);
// Expected output : 7

console.log(c);
// Expected output : 7

b = 256;
console.log(b);
// Expected output : 256
```

- 변수 a 에 처음 할당된 값은 'hello' 라는 문자열이다. 그 후 "a += ' world';" 의 과정을 통해 'hello' 문자열이 'hello world' 문자열로 바뀐것이다. 하지만, 이 과정을 자세하게 들여다 보면 기존의 'hello' 문자열이 사라진 것이 아니라 데이터 영역의 새로운 주소에 'hello world' 문자열 값이 할당되는 것이다. 그렇기에 'hello' 와 'hello world' 는 완전히 별개의 데이터인 것이다.

- 변수 b 에 7이 할당되었는데, 변수 c에도 7이 할당되었다. 앞서 배운 내용을 적용시켜 본다면, 처음에 b에 7이 할당 될 때는 우선 변수 영역의 임이의 주소에 b 라는 식별자를 할당하고 데이터 영역의 임이의 주소에 7 값을 저장한다. 그 다음 과정이 중요한데 앞서 b를 할당한것 처럼 c를 변수 영역의 임이의 주소에 c 라는 식별자를 할당하고 이제 7을 저장하려 하는데, 이때 7은 이미 b에 7을 저장할때 데이터영역의 임이의 주소에 저장되어 있기 때문에 추가로 임이의 주소에 값을 할당 하는 것이 아닌, b에 저장된 7의 주소를 c에도 연결하는 방식으로 주소를 **재활용** 한다. 그 후에 b의 값을 256으로 재할당하는 과정이 있는데 이는 위의 문자열 할당과 마찬가지로 기존의 7을 지우고 256값으로 대체하는 것이 아닌 7이 할당된 주소는 그대로 두고 새로운 주소에 256을 할당하여 그 주소를 b와 연결 하는 것이다.

:bulb: 위 두 예시와 같이 한 번 만든 값은 바꿀 수 없고, 변경은 새로 만드는 동작을 통해서만 이루어 진다. 이러한 성질을 **불변값** 의 성질이다. 한 번 만들어진 값은 가비지 컬렉팅을 하지 않는 이상 영원히 변하지 않는다.

### :meat_on_bone: 가변값 
- 기본형 데이터는 모두 **불변값** 이라고 했으니 **참조형 데이터** 는 모두 가변값일 것 같다. 일반적으로 기본적인 성질은 가변값인 경우가 많지만 설정에 따라 변경 불가능한 경우도 있고, 아예 **불변값** 으로 활용하는 방안도 있다.

<참조형 데이터 할당>
```js
let obj = {
        a : 1,
        b : 'test',
};
```
<참조형 데이터 할당 표>

| 주소 | 1 | 2 | 3 | 4 | ... |
|:------:|:---:|:---:|:---:|:---:|:---:|
| 데이터 |   | 이름: obj <br> 값: @11  |   |   |
| 주소 |  11  |  12  |  13  |  14  |
| 데이터 |  @31 ~ ?  |   |  1  |  'test'  |

| 주소 | 31 | 32 | 33 | 34 | ... |
|:------:|:---:|:---:|:---:|:---:|:---:|
| 데이터 |  이름: a <br> 값: @13  | 이름: b <br> 값: @14  |   |   |

**(1)** 변수 영역에 임의로 주소(@2)를 확보하여 그 주소의 식별자를 'obj' 로 할당한다.

**(2)** 데이터 영역에 값을 저장하려고 보니 여러 개의 프로퍼티로 이뤄진 데이터 그룹이다. 이 그룹 내부의 프로퍼티를 저장하기 위해 별도의 변수 영역을 마련하고, 그 영역의 주소(@31 ~ ?)를 데이터 영역의 데이터 저장공간(@11)에 저장한다.

**(3)** a,b 를 각각 해당 영역의 주소(@31, @32) 에 할당한다.

**(4)** 데이터 영역에서 숫자 1을 검색한 후, 검색 결과가 없으므로 임의로 주소(@13)를 확보하고 1을 저장한 후 (@31)에 있는 이름 a의 값에 (@13)을 연결한다. 마찬가지로 데이터 영역에서 'test' 의 검색결과가 없는 것을 확인 후, 임의로 주소(@14) 를 확보하고 'test' 문자열을 저장 후 (@32)에 있는 이름 b의 값에 (@14)를 연결한다.

:books: 참조형 데이터는 불변하지 않다 라고 보는 이유 

- 객체가 별도로 할애한 영역은 변수 영역일 뿐 '데이터 영역'은 기존의 메모리 공간을 그대로 활용한다. 
- 데이터 영역에 저장된 값은 모두 불변값이다.
- 변수에는 다른 값을 얼마든지 대입할 수 있다.

:bulb: 기본형 데이터와 달리 **참조형 데이터**는 '객체의 변수(프로퍼티) 영역'이 별도로 존재한다.

<참조형 데이터의 프로퍼티 재할당>

```js
let obj = {
        a : 1,
        b : 'test',
};
obj.a = 777;
```

:books: obj의 a 프로퍼티에 777을 할당해보자

- 데이터 영역에서 777 을 검색한 결과가 없기에 임의로 주소를 할당하여 이 주소를 (@31) 의 값과 연결시킨다.

:bulb: 새롭게 객체가 만들어 진것이 아니라 임의의 주소를 할당하여 저장한 것이기 때문에 기존의 값 1은 해당 주소(@13)에 그대로 있고 a의 데이터 주소만 바뀐 것이다.

<중첩된 참조형 데이터(객체)의 프로퍼티 할당>

- 중첩 객체(Nested object) : 참조형 데이터의 프로퍼티에 다시 참조형 데이터를 할당하는 경우.

```js
let obj = {
    x : 5,
    arr : [1,2,3],
};
```

- 우선 'obj'가 임의로 정해진 주소에 저장되고 'x,arr' 이 할당되는 과정은 앞서 다룬것과 큰 차이는 없다. 
- 여기서 발생하는 차이는 'arr' 의 값 [1,2,3] 을 할당할 때인데 그부분을 살펴보자

(1) arr 데이터영역의 값으로 배열이 담길 임의의 주소를 할당한다.

(2) 1과 2, 3을 검색한 결과 값이 존재하지 않기 때문에 1, 2, 3 을 임의로 지정된 주소에 값을 저장하고 이름에 인덱스를 부여한다.

(3) 할당된 주소의 범위를 arr의 데이터 영역 값에 연결된 주소의 데이터 영역 값에 할당한다.

<재할당>

- 기존의 값을 재할당 하는 경우 기존값의 참조 카운트가 1이었다가 재할당이 되면서 참조 카운트는 0이 되는데, 참조 카운트가 0인 메모리 주소는 **가비지 컬렉터** 의 수거 대상이 된다. 가비지 컬렉터는 런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화 상태에 임박할 때마다 자동으로 수거 대상들을 수거 한다. 수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈 공간이 된다.

### :meat_on_bone: 변수 복사 비교