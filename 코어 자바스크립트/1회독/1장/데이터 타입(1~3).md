# 데이터 타입(1~3) :star:
- 자바스크립트가 데이터를 처리하는 과정을 살펴봄으로써 **기본형 타입** 과 **참조형 타입** 이 서로 다르게 동작하는

이유를 이해하고 이를 적절히 활용할 수 있게 되는 것을 목표로 한다.

## :question: 기본형 and 참조형 
- 일반적으로 **기본형** 은 할당이나 연산시 복제되고, **참조형**은 참조된다고 알려져 있다.

    엄밀히 말하면 둘 모두 복제를 하긴 하는데 그 차이가 무엇인지 알아보자.

### :meat_on_bone: 기본형 (Primitive type)
- 값이 담긴 주솟값을 바로 복제한다.
- 기본형은 **불변성** 을 띈다.

### :meat_on_bone: 참조형 (Reference type)
- 값이 담긴 주솟값들로 이루어진 **묶음** 을 가리키는 주솟값을 복제한다.

<img src="https://github.com/leedbswo107/TIL/blob/main/%EC%BD%94%EC%96%B4%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/1%ED%9A%8C%EB%8F%85/1%EC%9E%A5/images/javaScriptDataType.png"  width="600" height="400"/>

  
***

## :question: 메모리와 데이터 
- 0 또는 1만 표현할 수 있는 하나의 **메모리 조각** 을 **비트(bit)** 라고 한다. **메모리** 는 매우 많은 비트들로 구성돼 있는데,
각 비트는 **고유한 식별자(Unique identifier)**  를 통해 위치를 확인할 수 있다. 하지만, 고작 0과 1만 표현할 수 있는 비트 단위로 
위치를 확인하는 것은 매우 비효율적이다. 이 부분은 비트를 여러개 묶어 하나의 단위로 여기는 방식으로 표현할 수 있는 값을 늘릴 수 
있고, 검색 시간 또한 줄일 수 있다.


- 많은 비트를 한 단위로 묶는 것은 검색 시간은 줄이고 표현 가능 데이터의 개수는 늘릴 수 있지만, 낭비가 되는 비트가 생길 수 있다.
그러므로 어느 정도 제약이 따르더라도 크게 문제가 되지 않을 적정 공간을 묶는 것이 좋다. 이 것의 결과로 **바이트(Byte)** 단위가 생겼다.

<img src="https://github.com/leedbswo107/TIL/blob/main/%EC%BD%94%EC%96%B4%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/1%ED%9A%8C%EB%8F%85/1%EC%9E%A5/images/byte.png"  width="300" height="300"/>

- 2byte 정수형 타입 (**short**) : 0을 포함한 -32768 ~ +32767 범위의 숫자만을 허용.
- 4byte 정수형 타입 (**int**) : 0을 포함한 -65536 ~ +65535 범위의 숫자만을 허용.

- 다른 언어와 달리 메모리 용량이 월등히 커진 상황에 등장한 자바스크립트는 상대적으로 메모리 관리에 대한 압박에서 자유로워서 메모리 공간을 
좀 더 넉넉하게 할당했다. **숫자** 의 경우 정수형인지 부동소수형인지를 구분하지 않고 64bit, 즉 8byte 를 확보한다. 이 덕분에 개발자가 
형변환을 걱정해야 하는 상황이 훨씬 덜 발생하게 됐다.

- 모든 데이터는 바이트 단위의 식별자, 즉 **메모리 주솟값(Memory address)** 을 통해 서로 구분하고 연결할 수 있다.

## :question: 식별자 (Identifier)
- 어떤 데이터를 식별하는 데 사용하는 이름, 즉 **변수명(Variable name)** 이다.
## :question: 변수 (Variable)
- 변수는 '변할수 있는 수' 이다. 수학 용어를 차용하여 숫자를 의미하는 '수'가 붙었을 뿐, 값은 숫자 이외에 데이터 타입이 들어올 수 있다.
- 영어 단어 variable은 원래 '변할 수 있다' 라는 형용사이지만 컴퓨터 용어로 쓸 때 '변할 수 있는 무언가' 라는 명사로 확장됐다. 여기서의 '무언가' 란 **데이터** 를 말한다.

### :books: 변수 선언
```js
let a;
// '변할 수 있는 데이터를 만든다. 이 데이터의 식별자(Variable name)는 a로 한다'
// 식별자 a 의 변수에는 데이터가 담겨있지 않은 상태로 현재 undefined 라고 볼 수 있다.
```

| 주소 | ... | 1002 | 1003 | 1004 | ... |
|---|---|---|---|---|---|
| 데이터 |   |   | 이름 : a <br> 값 : |   |   |

- 'let a;' 의 동작으로 컴퓨터는 메모리에서 비어있는 공간 하나늘 확보하고 표에서 임의로 1003번으로 주소를 지정했다. 이 공간의 이름(식별자)을 a라고 지정하는데
여기까지의 과정이 변수 선언 과정이다. 이후에 사용자가 a에 접근하고자 하면 컴퓨터는 메모리에서 a 라는 이름을 갖은 주소를 검색해 해당 공간의 데이터 값을 반환할 것이다.

### :books: 데이터 할당
```js
let a;
a = 'hello world !!!';
// 변수의 선언과 데이터 할당을 따로 진행

let a = 'hello world !!!';
// 변수의 선언과 데이터 할당을 한 줄로 진행
```

- 일반적으로 생각하면 위의 **변수 선언** 의 표에서 이름은 'a' 로 지정되었고 값 영역이 비어 있기 때문에 'hello world !!!' 데이터가 비어 있는 그 자리에 저장이 될 것
같지만, 값이 바로 저장되지 않고 'hello world !!!' 라는 데이터는 **데이터영역**에 별도의 주소를 갖은 데이터영역에 저장된다.

<변수 영역>
| 주소 | ... | 1002 | 1003 | 1004 | ... |
|---|---|---|---|---|---|
| 데이터 |   |   | 이름 : a <br> 값 : |   |   |

<데이터 영역>
| 주소 | ... | 3002 | 3003 | 3004 | ... |
|---|---|---|---|---|---|
| 데이터 |   |   | 'hello world !!!' |   |   |

(1) 변수 영역에서 빈 공간(1003)을 확보한다.

(2) 확보한 공간의 식별자를 a로 지정한다.

(3) 데이터 영역의 빈 공간(3003)에 문자열 'hello world !!!'를 저장한다.

(4) 변수 영역에서 a라는 식별자를 검색한다. (1003)

(5) 앞서 저장한 문자열의 주소(3003)을 변수영역(1003)의 데이터 값 공간에 대입한다.

### :boom: 왜 변수 영역에 값을 직접 대입하지 않을까?
- **데이터 변환** 을 자유롭게 할 수 있게 함과 동시에 메모리를 더욱 효율적으로 관리하기 위함. 
- 자바스크립트에서 숫자형 데이터는 8byte의 공간을 확보하는 반면에 문자열은 영어는 1byte 한글은 2byte 등으로 
필요 메모리 용량이 가변적이며 전체 글자 수 역시 가변적이기 때문에 특별히 정해진 규격이 없다.

### :question: 변수와 데이터를 별도의 공간에 나누어 저장하지 않는다면?
- 만약 미리 확보한 공간 내에서만 데이터 변환을 할 수 있다면 변환한 데이터를 다시 저장하기 위해서는 '확보된 공간을 
변환된 데이터 크기에 맞게 늘리는 작업' 이 선행돼야 한다. 해당 공간이 메모리 상의 가장 마지막에 있다면 뒤쪽으로 
늘리기만 하면 되기에 큰 어려움이 없으나, 만약 중간의 데이터를 늘려야하면 해당 공간보다 뒤에 저장된 데이터를 전부 뒤로
옮기고, 이동시킨 주소를 각 **식별자** 에 다시 연결하는 작업을 해야해서 처리해야 할 연산이 많아진다.

- 예시

    500개의 변수를 생성하여 모든 변수에 숫자 5를 할당하는 상황을 보면, 각 변수를 별개로 인식하려면 500개의 변수 공간을 확보해야하는데 
    각 변수 공간마다 매번 숫자 5를 할당하려 하면 숫자형은 8바이트가 필요하기에 총 4000(500*8)byte 를 써야한다. 

    각각을 할당하는 대신에 5를 별도의 공간에 한 번만 저장하고 해당 주소를 입력한다면, 주소공간을 2byte라고 가정한다면 1008(500*2+8)byte 만을 사용하면 된다.

    이처럼 변수영역과 데이터영역을 구분하면 중복된 데이터에 대한 처리 효율이 높아진다.

:bulb: 그렇기에 변수와 데이터를 별도의 공간에 저장하고 주소로 연결하는 방식이 최적의 방식인 것이다.

### :question: 새로운 데이터를 할당하는 경우의 동작

```js
let a = 'hello world !!!';
console.log(a);
// Expected output : 'hello world !!!'

a = 'New data assignment !!!';
console.log(a);
// Expected output : 'New data assignment !!!'
```

<변수 영역>
| 주소 | ... | 1002 | 1003 | 1004 | ... |
|---|---|---|---|---|---|
| 데이터 |   |   | 이름 : a <br> 값 : |   |   |

<데이터 영역>
| 주소 | ... | 3002 | 3003 | 3004 | ... |
|---|---|---|---|---|---|
| 데이터 |   |   | 'hello world !!!' | 'New data assignment !!!' |   |

- 식별자 a에는 기존에 'hello world !!!' 라는 문자열이 저장되어 있었다. 하지만, 그 후에 'New data assignment !!!' 라는 값을 다시 
할당 하는경우, 기존의 데이터영역 3003 주소에 있는 'hello world !!!' 의 값이 사라지는게 아닌 데이터영역에서 새롭게 임의로 할당된 3004 주소에 
'New data assignment !!!' 값을 저장하고, 변수 영역 1003에 데이터영역 값에 3004 의 주소를 연결한다. 

:bulb: 즉, 별도로 값 자체를 지우는 명령을 하지 않는 이상, 데이터를 재할당 하거나 기존 데이터에 추가로 데이터를 붙이는 경우 기존의 데이터는 기존에 할당된
주소에 그대로 저장되어 있고, 새로운 주소에 새롭게 재할당 되었거나 추가된 데이터가 저장되는 것이다.

## :guardsman: 느낀점
코어 자바스크립트 책으로 보다 심도 있는 학습을 시작하였다. 처음에 변수의 할당에 대해 배웠을 때는 이해하기 쉽게 설명하려 하신건지 변수에 데이터가 저장되는 
부분에 대한 설명을 간소하게 진행한거 같다. 이번 학습을 통해 변수에 데이터가 저장될 때 변수 영역과 데이터 영역이 따로 있어서 변수 영역의 데이터 이름은 변수명과 같고
데이터의 값에는 실제 데이터가 바로 저장되는 것이 아니라 데이터가 저장되어 있는 데이터 영역의 주소가 연결됨을 알 수 있었고, 중복 데이터를 다룰 때 중복되는 데이터를 여러
공간에 할당할 필요 없이 그 데이터가 저장된 주소를 변수 영역의 값과 연결함으로 효율을 높일 수 있음을 알 수 있었다. 
