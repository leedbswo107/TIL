# 데이터 타입(4) :star:
- 자바스크립트가 데이터를 처리하는 과정을 살펴봄으로써 **기본형 타입** 과 **참조형 타입** 이 서로 다르게 동작하는 이유를 이해하고 이를 적절히 활용할 수 있게 되는 것을 목표로 한다.

## :question: 기본형 데이터와 참조형 데이터
### :meat_on_bone: 불변값
- 변수와 상수를 구분하는 성질은 '변경 가능성' 이다. 바꿀 수 있으면 **변수** 
바꿀 수 없으면 **상수** 이다.

- 불변값과 상수를 같은 개념으로 오해하기 쉽기에 명확히 구분할 수 있어야 한다.   
변수와 상수를 구분 짓는 변경 가능성의 대상은 **변수 영역** 메모리이다.
한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건이다.반면 불변성 여부를 구분할 때의 변경 가능성의 대상은 **데이터 영역** 메모리이다.

- **기본형 데이터** 에는 **숫자, 문자열, boolean, null, undefined, Symbol** 이 있고, 이 것은 모두 **불변값** 이다.

<변수>
```js
let a = 0;
console.log(a);
// Expected output : 0

a = 1;
console.log(a);
// Expected output : 1
```
<상수>
```js
const a = 0;
console.log(a);
// Expected output : 0

a  = 1;
console.log(a);
// Expected output : const 'TypeError: Assignment to constant variable.'
```

:bulb: const 는 constant 의 앞을 딴 것으로 **상수** 를 선언하는 자료형이다.

<예제>

```js
let a = 'hello';
console.log(a);
// Expected output : 'hello'

a += ' world';
console.log(a);
// Expected output : 'hello world'

let b = 7;
let c = 7;
console.log(b);
// Expected output : 7

console.log(c);
// Expected output : 7

b = 256;
console.log(b);
// Expected output : 256
```

- 변수 a 에 처음 할당된 값은 'hello' 라는 문자열이다. 그 후 "a += ' world';" 의 과정을 통해 'hello' 문자열이 'hello world' 문자열로 바뀐것이다. 하지만, 이 과정을 자세하게 들여다 보면 기존의 'hello' 문자열이 사라진 것이 아니라 데이터 영역의 새로운 주소에 'hello world' 문자열 값이 할당되는 것이다. 그렇기에 'hello' 와 'hello world' 는 완전히 별개의 데이터인 것이다.

- 변수 b 에 7이 할당되었는데, 변수 c에도 7이 할당되었다. 앞서 배운 내용을 적용시켜 본다면, 처음에 b에 7이 할당 될 때는 우선 변수 영역의 임이의 주소에 b 라는 식별자를 할당하고 데이터 영역의 임이의 주소에 7 값을 저장한다. 그 다음 과정이 중요한데 앞서 b를 할당한것 처럼 c를 변수 영역의 임이의 주소에 c 라는 식별자를 할당하고 이제 7을 저장하려 하는데, 이때 7은 이미 b에 7을 저장할때 데이터영역의 임이의 주소에 저장되어 있기 때문에 추가로 임이의 주소에 값을 할당 하는 것이 아닌, b에 저장된 7의 주소를 c에도 연결하는 방식으로 주소를 **재활용** 한다. 그 후에 b의 값을 256으로 재할당하는 과정이 있는데 이는 위의 문자열 할당과 마찬가지로 기존의 7을 지우고 256값으로 대체하는 것이 아닌 7이 할당된 주소는 그대로 두고 새로운 주소에 256을 할당하여 그 주소를 b와 연결 하는 것이다.

:bulb: 위 두 예시와 같이 한 번 만든 값은 바꿀 수 없고, 변경은 새로 만드는 동작을 통해서만 이루어 진다. 이러한 성질을 **불변값** 의 성질이다. 한 번 만들어진 값은 가비지 컬렉팅을 하지 않는 이상 영원히 변하지 않는다.

### :meat_on_bone: 가변값 
- 기본형 데이터는 모두 **불변값** 이라고 했으니 **참조형 데이터** 는 모두 가변값일 것 같다. 일반적으로 기본적인 성질은 가변값인 경우가 많지만 설정에 따라 변경 불가능한 경우도 있고, 아예 **불변값** 으로 활용하는 방안도 있다.

<참조형 데이터 할당>
```js
let obj = {
        a : 1,
        b : 'test',
};
```
<참조형 데이터 할당 표>

| 주소 | 1 | 2 | 3 | 4 | ... |
|:------:|:---:|:---:|:---:|:---:|:---:|
| 데이터 |   | 이름: obj <br> 값: @11  |   |   |
| 주소 |  11  |  12  |  13  |  14  |
| 데이터 |  @31 ~ ?  |   |  1  |  'test'  |

| 주소 | 31 | 32 | 33 | 34 | ... |
|:------:|:---:|:---:|:---:|:---:|:---:|
| 데이터 |  이름: a <br> 값: @13  | 이름: b <br> 값: @14  |   |   |

**(1)** 변수 영역에 임의로 주소(@2)를 확보하여 그 주소의 식별자를 'obj' 로 할당한다.

**(2)** 데이터 영역에 값을 저장하려고 보니 여러 개의 프로퍼티로 이뤄진 데이터 그룹이다. 이 그룹 내부의 프로퍼티를 저장하기 위해 별도의 변수 영역을 마련하고, 그 영역의 주소(@31 ~ ?)를 데이터 영역의 데이터 저장공간(@11)에 저장한다.

**(3)** a,b 를 각각 해당 영역의 주소(@31, @32) 에 할당한다.

**(4)** 데이터 영역에서 숫자 1을 검색한 후, 검색 결과가 없으므로 임의로 주소(@13)를 확보하고 1을 저장한 후 (@31)에 있는 이름 a의 값에 (@13)을 연결한다. 마찬가지로 데이터 영역에서 'test' 의 검색결과가 없는 것을 확인 후, 임의로 주소(@14) 를 확보하고 'test' 문자열을 저장 후 (@32)에 있는 이름 b의 값에 (@14)를 연결한다.

:books: 참조형 데이터는 불변하지 않다 라고 보는 이유 

- 객체가 별도로 할애한 영역은 변수 영역일 뿐 '데이터 영역'은 기존의 메모리 공간을 그대로 활용한다. 
- 데이터 영역에 저장된 값은 모두 불변값이다.
- 변수에는 다른 값을 얼마든지 대입할 수 있다.

:bulb: 기본형 데이터와 달리 **참조형 데이터**는 '객체의 변수(프로퍼티) 영역'이 별도로 존재한다.

<참조형 데이터의 프로퍼티 재할당>

```js
let obj = {
        a : 1,
        b : 'test',
};
obj.a = 777;
```

:books: obj의 a 프로퍼티에 777을 할당해보자

- 데이터 영역에서 777 을 검색한 결과가 없기에 임의로 주소를 할당하여 이 주소를 (@31) 의 값과 연결시킨다.

:bulb: 새롭게 객체가 만들어 진것이 아니라 임의의 주소를 할당하여 저장한 것이기 때문에 기존의 값 1은 해당 주소(@13)에 그대로 있고 a의 데이터 주소만 바뀐 것이다.

<중첩된 참조형 데이터(객체)의 프로퍼티 할당>

- 중첩 객체(Nested object) : 참조형 데이터의 프로퍼티에 다시 참조형 데이터를 할당하는 경우.

```js
let obj = {
    x : 5,
    arr : [1,2,3],
};
```

- 우선 'obj'가 임의로 정해진 주소에 저장되고 'x,arr' 이 할당되는 과정은 앞서 다룬것과 큰 차이는 없다. 
- 여기서 발생하는 차이는 'arr' 의 값 [1,2,3] 을 할당할 때인데 그부분을 살펴보자

(1) arr 데이터영역의 값으로 배열이 담길 임의의 주소를 할당한다.

(2) 1과 2, 3을 검색한 결과 값이 존재하지 않기 때문에 1, 2, 3 을 임의로 지정된 주소에 값을 저장하고 이름에 인덱스를 부여한다.

(3) 할당된 주소의 범위를 arr의 데이터 영역 값에 연결된 주소의 데이터 영역 값에 할당한다.

<재할당>

- 기존의 값을 재할당 하는 경우 기존값의 참조 카운트가 1이었다가 재할당이 되면서 참조 카운트는 0이 되는데, 참조 카운트가 0인 메모리 주소는 **가비지 컬렉터** 의 수거 대상이 된다. 가비지 컬렉터는 런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화 상태에 임박할 때마다 자동으로 수거 대상들을 수거 한다. 수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈 공간이 된다.

### :meat_on_bone: 변수 복사 비교
```js
let a = 10;
let b = a;

let obj1 = {c : 10, d : 'test'};

let obj2 = obj1;
```
- a 의 데이터 값의 주소로 이동하면 데이터 값이 10임을 알 수 있다. b 에 a 를 할당하는 과정은 우선 a 식별자를 검색하여 검색결과가 있음을 확인하고 그 데이터 값을 b에 할당한다.
- obj1 의 데이터 값의 주소로 이동하면 객체를 이루는 데이터의 범위 주소가 나오고 각각의 주소로 이동하면 c 와 d 의 데이터 주소가 나와 그 주소를 통해 각각 10, 'test' 의 데이터 값을 확인 할 수 있다. 여기서 'obj2 = obj1' 으로 복사하는 방식은 얕은 복사로 obj2 가 obj1 의 변수와 식별자, 데이터를 모두 가져오는 것은 맞지만, obj2 에 데이터 값에 저장된 것은 obj1 의 데이터 값의 주소이다. **얕은 복사** 는 **깊은 복사** 와 달리 후에 동작에서 큰 차이를 보인다.

#### :poultry_leg: 얕은 복사

- 위에서 진행한 객체의 복사는 얕은 복사라고 했다. 그렇다면 얕은 복사를 했을 때 객체 값을 변경한다면 어떻게 될지 살펴보자.

```js
let a = 10;
let b = a;
let obj1 = {c : 10, d : 'test'};
let obj2 = obj1;

b = 15;
obj2.c = 20;
```

- 위에서 진행한 바와 같이 데이터의 얕은 복사가 이루어지고 b 는 15로 obj2 의 c 는 20으로 변경하였다. 단순하게 생각하면 obj2.c 의 값을 바꾼 것 이기 때문에 obj1.c 는 10 이고 obj2.c 는 20 나타낼 것으로 기대된다. 하지만, 기대한 바와는 다른 결과값이 나오는데 왜 그런지 그 과정을 살펴보자.

- 우선 obj2 는 obj1 의 데이터영역의 주소를 공유한다. 그렇기에 그 주소로 이동하여 c 를 찾을 것이고 그 c 의 데이터 주소로 이동하여 데이터 값을 10 에서 20 으로 변경을 한다. 이로 인해 obj1 와 obj2 의 c 는 같은 주소로 연결되어 있기 때문에 obj2 의 c 만 20 으로 변경되는 것이 아닌 obj1 의 c 또한 20 으로 변경된다.

```js
// 위 코드의 결과 a 와 b, obj1 과 obj2 의 비교 
a !== b;
obj1 === obj2;
```

:bulb: 이것이 기본형과 참조형의 가장 큰 차이점이다. 기본형은 주솟값을 복사하는 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치는 차이가 있다.

- 그렇다면 객체의 프로퍼티를 변경하는 것이 아닌 객체 자체를 새로 할당한다면 어떻게 될지 알아보자.

- 위와 마찬가지로 할당과 복사는 동일한 과정으로 이루어 진다. 다만, obj2 에 새로운 객체를 할당하면 객체 안에 같은 값이 존재하더라도 그 별도의 주소에 저장되기 때문에 더 이상 obj1 과 obj2 는 다른 주소를 갖게 된다.

:bulb: 즉, 참조형 데이터가 **가변값** 이라고 설명할 때의 **가변** 은 참조형 데이터 자체를 변경하는 경우가 아니라 그 내부의 **프로퍼티** 를 변경할 때만 성립한다.


## :guardsman: 느낀점
공부를 하면서 기본형 데이터는 모두 불변값이라고 하고 참조형 데이터는 가변값이라고 하는데, 막상 사용할 때 보면 기본형 데이터의 값을 바꿀 수 있다는 것에 의문을 갖고 있었는데, 이번 학습을 진행하면서 참조형은 객체 안에 프로퍼티를 할당할 수 있고 그 프로퍼티는 변경이 가능하여 가변값이라 할 수 있고, 기본형은 일단 한번 프로퍼티가 정해지면 그 프로퍼티를 변경할 수 없다는 점에서 불변값이라는 것을 알 수 있었다. 프리코스나 코드테스트를 진행하면서 이 개념에 대해 얕은 지식을 가지고 참여를 해도 지장이 없었다는 등의 안일한 생각을 했었으나, 자세한 내용을 알고 개념을 습득하니 더 섬세한 조작이 필요한 부분이구나 라는 생각이 들었다. 1장의 4절범위가 쪽수에 비해 이해하는 시간이 오래 걸렸으나 이해를 하고 나서 정리를 하니 그 시간의 중요성을 몸소 체험한 장이었다. 이 책을 완주하는데 시간은 오래걸릴게 당연하나 이 책으로 얻어가는 지식이 처음부터 이렇게 소중함을 느낄 수 있어 뜻깊었다.