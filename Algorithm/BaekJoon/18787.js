/**
 * 문제
 * 농부 존의 사촌 벤은 우연히도 미친 과학자입니다. 보통 이런 성격 때문에 가족 모임에서 상당한 마찰이 생기지만, 때로는 도움이 될 수도 있습니다. 특히 농부 존이 소 때문에 독특하고 특이한 문제에 직면했을 때 더욱 그렇습니다. 
 * 농부 존은 현재 소들에게서 독특하고 특이한 문제에 직면해 있습니다. 그는 최근 N소 (1 <= N <= 1000) 홀스타인과 건지라는 두 가지 다른 품종으로 구성되었습니다. 그는 자신의 주문서에 소들을 다음과 같은 순서로 명시했습니다. N각 문자는 H(홀스타인) 또는 G(건지)였습니다. 안타깝게도 소들이 그의 농장에 도착하여 줄을 세웠을 때, 그들의 품종은 원래의 품종과 다른 품종으로 나타났습니다.
 * 이 두 문자열을 다음과 같이 부르자. A그리고 B, 어디 A는 Farmer John이 원래 원했던 품종 식별자 문자열입니다. B소들이 도착했을 때 그가 보는 줄입니다. 단순히 소들을 재배치하는지 확인하는 것보다 B얻기에 충분하다 A농부 존은 사촌 벤에게 과학적 독창성을 발휘해 문제를 해결해 달라고 부탁합니다. 
 * 몇 달간의 작업 끝에 벤은 놀라운 기계, 다중 소 품종 플리피네이터 3000을 개발했습니다. 이 기계는 소의 모든 하위 문자열을 가져와 품종을 토글링할 수 있습니다. 하위 문자열의 모든 H는 G로, 모든 G는 H로 토글링됩니다. 농부 존은 현재 순서를 변경하기 위해 이 기계를 적용해야 하는 최소 횟수를 알아내고자 합니다. B원래 원하는 주문으로 A안타깝게도 벤의 미친 과학자 기술은 독창적인 장치를 만드는 것 이상으로 확장되지 않으므로 농부 존이 이 계산 수수께끼를 풀도록 도와야 합니다.
 * 
 * 출력
 * 기계가 B를 A로 변형하기 위해 적용해야 하는 최소 횟수를 출력하시오.
 */
const [N, A, B] = require('fs').readFileSync('./input.txt', 'utf-8').trim().split('\n');
let count = 0;
let status = true;
for (let i = 0; i < +N; i++) {
  if (status && A[i] !== B[i]) {
    count++;
    status = false;
  } else if (!status && A[i] === B[i]) status = true;
}
console.log(count);