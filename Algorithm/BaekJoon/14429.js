/**
 * 문제
 * 수련회 첫 날 밤을 맞아 유진이와 규용이는 배스킨라빈스 31 게임으로 진 사람을 정해 간장을 마시려고 한다. 게임의 룰은 다음과 같다.
 * 유진이와 규용이는 한 줄로 나란히 앉아있다. 맨 왼쪽에는 유진이가 앉는다.
 * 게임은 유진이부터 시작하여 오른쪽으로 진행한다.
 * 자기 차례가 되면 1부터 j사이의 자연수를 1~m개 연달아 말할 수 있다. 무조건 1개 이상 말해야 한다.
 * j를 말하는 사람이 진다.
 * 게임을 몇 번이나 해 보았지만 유진이만 계속 간장을 먹었다. 화가 난 유진이는 인터넷을 검색해 반드시 이길 수 있는 승리 전략을 찾았다. 승리 전략은 이러하다.
 * 전체 개수 j-1을 1+m으로 나누어 나머지 r을 구한다.
 * 전체의 숫자 중 r번째의 숫자가 필승 숫자의 초항이다.
 * 초항부터 1+m을 계속 더해 가면 그것이 곧 필승 숫자들이다.
 * 게임을 시작하면 무조건 필승 숫자의 초항까지 말한다.
 * 상대가 몇 개를 말하던 다음 턴에 자신이 필승 숫자를 포함해 말해나가면 게임에서 이기게 된다.
 * 예) 31을 말하면 지는 게임에서 한 턴에 1~3번까지 말할 수 있다면 (31-1)÷4=7...2 이므로 필승 숫자는 2, 6, 10, 14, 18, 22…가 된다.
 * ‘다음의 승리 전략을 이용’하여 유진이가 게임에서 이기는 최소 턴의 수를 길이라고 할 때, n번의 게임 후에 길이가 가장 짧은 게임의 번호와 길이를 구하시오.
 * 
 * 출력
 * 길이가 가장 짧은 게임의 번호와 길이를 출력한다. 만약 길이가 가장 짧은 게임이 두 개 이상일 경우 가장 먼저 입력된 번호와 그 길이를 출력한다.
 */
const [n, ...plays] = require('fs').readFileSync(process.platform === 'linux' ? 0 : './input.txt', 'utf-8').trim().split('\n');
const len = new Array(+n);
const solution = (j, m) => {
  const r = (j - 1) % (m + 1);
  let winningNum = r;
  let count = 0;
  while (winningNum < j) {
    winningNum += (m + 1);
    count += 2;
  }
  return count;
}
plays.forEach((e, i) => {
  const [J, M] = e.split(' ').map(Number);
  len[i] = solution(J, M);
});
const min = Math.min(...len);
const minIdx = len.indexOf(min);
console.log(minIdx + 1, min);