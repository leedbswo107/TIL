/**
 * 문제
 * 코레스코 콘도의 각 방에는 디지털 시계가 설치되어 있다. 디지털 시계에는 4개의 숫자가 표현될 수 있으며, 이것은 'hh:mm'의 형식으로 시간을 표현한다. 즉, 앞의 두 자리는 시간을, 뒤의 두 자리는 분을 표현한다. 시간은 00:00부터 23:59까지의 24시 체계를 쓴다.
 * 디지털 시계의 각 숫자는 15개의 발광다이오드로 표현이 된다. 5x3형태로 배열되어 있는 발광 다이오드들 중 특정한 몇 칸이 켜져서 숫자를 나타내는 것이다. 다음과 같다. '#'은 불이 켜져 있는 다이오드를, '.'은 그렇지 않은 다이오드를 나타낸다.
 * ###  ..#  ###  ###  #.#  ###  ###  ###  ###  ###
 * #.#  ..#  ..#  ..#  #.#  #..  #..  ..#  #.#  #.#
 * #.#  ..#  ###  ###  ###  ###  ###  ..#  ###  ###
 * #.#  ..#  #..  ..#  ..#  ..#  #.#  ..#  #.#  ..#
 * ###  ..#  ###  ###  ..#  ###  ###  ..#  ###  ###
 * 그런데 투숙객이 아침에 일어나서 시계를 보니 몇 개의 발광다이오드가 고장나 불이 켜지지 않은 것을 발견했다. (켜지지 않아야 하는 발광다이오드가 켜진 경우는 없다)모든 투숙객은 자신이 부지런하고 믿는 사람들이기 때문에 투숙객은 가능하면 현재 시각을 빠른 시각(00:00에 가까운 시각이 늘 빠른 시각이다)으로 생각하고 싶다.
 * 일부 발광다이오드가 고장난 디지털 시계의 네 숫자가 주어졌을 때, 이러한 배치가 가능한 가장 빠른 시각을 구하는 프로그램을 작성하시오.
 * 
 * 출력
 * 이러한 배치가 가능한 가장 빠른 시각을 출력한다.
 */
const patterns = {
  0: ['#','#','#','#','.','#','#','.','#','#','.','#','#','#','#'],
  1: ['.','.','#','.','.','#','.','.','#','.','.','#','.','.','#'],
  2: ['#','#','#','.','.','#','#','#','#','#','.','.','#','#','#'],
  3: ['#','#','#','.','.','#','#','#','#','.','.','#','#','#','#'],
  4: ['#','.','#','#','.','#','#','#','#','.','.','#','.','.','#'],
  5: ['#','#','#','#','.','.','#','#','#','.','.','#','#','#','#'],
  6: ['#','#','#','#','.','.','#','#','#','#','.','#','#','#','#'],
  7: ['#','#','#','.','.','#','.','.','#','.','.','#','.','.','#'],
  8: ['#','#','#','#','.','#','#','#','#','#','.','#','#','#','#'],
  9: ['#','#','#','#','.','#','#','#','#','.','.','#','.','.','#']
}
const input = require('fs').readFileSync(0, 'utf-8').trim().split('\n').map(e => e.split(' '));
const reassemble = Array.from({length: input[0].length}, () => []);
const result = [];
input.forEach(e => e.forEach((_, i) => reassemble[i].push(...e[i].split(''))));
reassemble.forEach((e, pos) => {
  const diffCount = new Array(10).fill(0);
  let idx = pos === 0 ? 3 : (pos === 2 ? 6 : 10);
  for (let i = 0; i < idx; i++) {
    for (let j = 0; j < 15; j++) {
      if(e[j] !== patterns[i][j]) {
        if(e[j] === '#' && patterns[i][j] === '.') diffCount[i]++;  
        continue;
      }
    }
  }
  result.push(diffCount.indexOf(Math.min(...diffCount)));
});
console.log(`${result[0]}${result[1]}:${result[2]}${result[3]}`);
